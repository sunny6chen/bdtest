#1. API Key & Secret
* **Key**: f12793c2-7f0f-49d8-8151-0129596ae91b

* **Secret**: 4mA1y7U3xKhXAwB3D4CRqmS6ie88XQmi 

    **注：加解密时只需要前16位**

#2. 使用手机号关联画像API
* **HTTP POST url**：*http://106.15.57.39:9888/bd/consumer?apikey=上面的Key*
* **加密前的数据**：解密后为如下Json格式：

 ```json
 {'phone':'需要查询的手机号'}
 ```

* **加密后Body数据以及传输格式**：

 ```json
 {
 	'data':'AES-128-CBC对称加密后的数据'
 }
 ```

* **输出结果加密前的数据:**
  * 如果查询到手机号关联的用户画像，code返回ok，并返回输入的手机号及对应的用户画像。
  * 如果没有查询到手机号关联的用户画像，code返回fail。


 ```json
 {
     'age':'xxxxx',
     ...
     'phone':'查询时的手机号',
     'code':'ok/fail'
 }	
 ```

* **输出结果加密后数据以及传输格式:**

  ```json
  {
  	'data':'AES-128-CBC对称加密后的数据'
  }
  ```

  ​	**注**：整个过程都是以**json**格式进行传输，加密前的数据都进行过**UTF-8**编   码，然后再进行加密

* **加密注意：**

  * 数据加密都是采用**AES-128-CBC**对称加密,加密后用**base64**编码输出
  * 在**encrypt**方法和**decrypt**方法内**IV** 为上面的**Key**;而**key** 为上面的**Secret**
  * 加密时字节数不足时，采用**PKCS5** 进行填充
  * 加密只需要加密一层，不需要多层加密

* **错误时输出：**

  ```json
  {
    'code':'fail',
    'error':'xxx错误信息'
  }
  ```

  ​

#3. 加密方法及Java代码

* 为了保护数据及多语言互通，采用了AES-128，CBC对称加密方法，对输入和输出统一加密，加密后用base64编码输出，便于网络传输。Java代码如下：

 ```java
 import javax.crypto.Cipher;
 import javax.crypto.spec.IvParameterSpec;
 import javax.crypto.spec.SecretKeySpec;

 import java.util.Base64;
 import java.util.UUID;

 import javax.crypto.KeyGenerator;
 import javax.crypto.SecretKey;

 class CryptoMngr {	
 	public static String ALGORITHM = "AES";
 	private static String AES_CBS_PADDING = "AES/CBC/Pkcs5Padding";

 	public static byte[] encrypt(final byte[] key, final byte[] IV, final byte[] message) throws Exception {
 		return CryptoMngr.encryptDecrypt(Cipher.ENCRYPT_MODE, key, IV, pad_zero(message, 16));
 	}

 	public static byte[] decrypt(final byte[] key, final byte[] IV, final byte[] message) throws Exception {
 		return CryptoMngr.encryptDecrypt(Cipher.DECRYPT_MODE, key, IV, message);
 	}

 	private static byte[] encryptDecrypt(final int mode, final byte[] key, final byte[] IV, final byte[] message)
 			throws Exception {
 		final Cipher cipher = Cipher.getInstance(AES_CBS_PADDING);
 		final SecretKeySpec keySpec = new SecretKeySpec(key, ALGORITHM);
 		final IvParameterSpec ivSpec = new IvParameterSpec(IV);
 		cipher.init(mode, keySpec, ivSpec);
 		return cipher.doFinal(message);
 	}

 	private static byte[] pad_zero(byte[] data, int blockSize) {
 		int plaintextLength = data.length;
 		if (plaintextLength % blockSize != 0) {
 	   		plaintextLength = plaintextLength + (blockSize - (plaintextLength % blockSize));
 		}
 		
 		byte[] plaintext = new byte[plaintextLength];
 		System.arraycopy(data, 0, plaintext, 0, data.length);
 		return plaintext;
   	}
 }

 public class AesTest {

 	private static int AES_128 = 128;
 	// 上面提供的API Secret的前16个字符，妥善收藏，请勿公开
   	private static String strKey = "4mA1y7U3xKhXAwB3D4CRqmS6ie88XQmi".substring(0, 16);
   	// 上面提供的API Key的前16个字符
   	private static String strIV = "f12793c2-7f0f-49d8-8151-0129596ae91b".substring(0, 16);


 	public static void main(String[] args) throws Exception {
         KeyGenerator keyGenerator = KeyGenerator.getInstance(CryptoMngr.ALGORITHM);
         keyGenerator.init(AES_128);

         String testString = "Test String";
         System.out.println("1. Message to Encrypt: " + testString);

         // 加密过程
         byte[] cipherText = CryptoMngr.encrypt(strKey.getBytes(), strIV.getBytes(), testString.getBytes());
         System.out.println("2. Encrypted Text: " + Base64.getEncoder().encodeToString(cipherText));

         // 解密过程
         byte[] decryptedString = CryptoMngr.decrypt(strKey.getBytes(), strIV.getBytes(), cipherText);
         String decryptedStr = new String(decryptedString);
         System.out.println("3. Decrypted Message : " + decryptedStr);
 	}
 }	
 ```