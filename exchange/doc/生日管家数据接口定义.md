#1. API Key & Secret
* **Key**: cdcd8132-ae1a-4098-80f7-7abdf0313399

* **Secret**: mABKue3DGqxuNQh6Mj78nUQOOymzDSYF 

  **注：加解密时只需要前16位**

#2. 提供手机号关联画像API
* **HTTP POST url**：*https://extapi.octinn.com/nameService/phone?apikey=上面的Key*

* **接受的数据加密前**：解密后为如下Json格式：

 ```json
 {'phone':'需要查询的手机号'}
 ```

* **接受加密后Body数据以及传输格式**：

 ```json
  {
  	'data':'AES-128-CBC对称加密后的数据'
  }
 ```

* **输出结果加密前的数据:**
  - 如果查询到手机号关联的用户画像，code返回ok，并返回输入的手机号及对应的用户画像。
  - 如果没有查询到手机号关联的用户画像，code返回fail。

```json
{
     'age':'xxxxx',
     ...
     'phone':'查询时的手机号',
     'code':'ok/fail'
 }	
```

* **输出结果加密后数据以及传输格式:**

```json
{
	'data':'AES-128-CBC对称加密后的数据'
}
```

**注**：整个过程都是以**json**格式进行传输，加密前的数据都进行过**UTF-8**编   码，然后再进行加密

* **加密注意：**
  - 数据加密都是采用**AES-128-CBC**对称加密,加密后用**base64**编码输出
  - 在**encrypt**方法和**decrypt**方法内**IV** 为上面的**Key**;而**key** 为上面的**Secret**
  - 加密时字节数不足时，采用**PKCS5** 进行填充
* **错误时输出：**

```json
{
  'code':'fail',
  'error':'xxx错误信息'
}
```



# 3.数据字段说明：

| 字段                              | 含义               |
| ------------------------------- | ---------------- |
| age（ 95+ : 95后 ,95-  :  95前 ）   | 年龄               |
| fn                              | 姓                |
| fn_available                    | 姓的可信度            |
| nm                              | 名                |
| nm_available                    | 名的可信度            |
| organization                    | 公司/组织/机构(如：生日管家) |
| other_name                      | 其他名字             |
| recorded_count                  | 被记录次数            |
| sex  ( 0 - 女(可信度) , 1 - 男(可信度)) | 性别               |
| title                           | 头衔/称呼等(如:经理、老板)  |
| phone                           | 手机号              |
| code (ok/fail)                  | 是否匹配到数据          |



# 4.加解密方法及PHP代码

* 为了保护数据及多语言互通，采用了AES-128，CBC对称加密方法，对输入和输出统一加密，加密后用base64编码输出，便于网络传输。

  * 加密方式参考：[https://github.com/illuminate/encryption]

  ```php
  <?php
  namespace Illuminate\Encryption;
  use RuntimeException;
  use Illuminate\Contracts\Encryption\DecryptException;
  use Illuminate\Contracts\Encryption\EncryptException;
  use Illuminate\Contracts\Encryption\Encrypter as EncrypterContract;
  class Encrypter implements EncrypterContract
  {
      /**
       * The encryption key.
       *
       * @var string
       */
      protected $key;
      /**
       * The algorithm used for encryption.
       *
       * @var string
       */
      protected $cipher;
      /**
       * Create a new encrypter instance.
       *
       * @param  string  $key
       * @param  string  $cipher
       * @return void
       *
       * @throws \RuntimeException
       */
      public function __construct($key, $cipher = 'AES-128-CBC')
      {
          $key = (string) $key;
          if (static::supported($key, $cipher)) {
              $this->key = $key;
              $this->cipher = $cipher;
          } else {
              throw new RuntimeException('The only supported ciphers are AES-128-CBC and AES-256-CBC with the correct key lengths.');
          }
      }
      /**
       * Determine if the given key and cipher combination is valid.
       *
       * @param  string  $key
       * @param  string  $cipher
       * @return bool
       */
      public static function supported($key, $cipher)
      {
          $length = mb_strlen($key, '8bit');
          return ($cipher === 'AES-128-CBC' && $length === 16) ||
                 ($cipher === 'AES-256-CBC' && $length === 32);
      }
      /**
       * Create a new encryption key for the given cipher.
       *
       * @param  string  $cipher
       * @return string
       */
      public static function generateKey($cipher)
      {
          return random_bytes($cipher == 'AES-128-CBC' ? 16 : 32);
      }
      /**
       * Encrypt the given value.
       *
       * @param  mixed  $value
       * @param  bool  $serialize
       * @return string
       *
       * @throws \Illuminate\Contracts\Encryption\EncryptException
       */
      public function encrypt($value, $serialize = true)
      {
          $iv = random_bytes(openssl_cipher_iv_length($this->cipher));
          // First we will encrypt the value using OpenSSL. After this is encrypted we
          // will proceed to calculating a MAC for the encrypted value so that this
          // value can be verified later as not having been changed by the users.
          $value = \openssl_encrypt(
              $serialize ? serialize($value) : $value,
              $this->cipher, $this->key, 0, $iv
          );
          if ($value === false) {
              throw new EncryptException('Could not encrypt the data.');
          }
          // Once we have the encrypted value we will go ahead base64_encode the input
          // vector and create the MAC for the encrypted value so we can verify its
          // authenticity. Then, we'll JSON encode the data in a "payload" array.
          $mac = $this->hash($iv = base64_encode($iv), $value);
          $json = json_encode(compact('iv', 'value', 'mac'));
          if (json_last_error() !== JSON_ERROR_NONE) {
              throw new EncryptException('Could not encrypt the data.');
          }
          return base64_encode($json);
      }
      /**
       * Encrypt a string without serialization.
       *
       * @param  string  $value
       * @return string
       */
      public function encryptString($value)
      {
          return $this->encrypt($value, false);
      }
      /**
       * Decrypt the given value.
       *
       * @param  mixed  $payload
       * @param  bool  $unserialize
       * @return string
       *
       * @throws \Illuminate\Contracts\Encryption\DecryptException
       */
      public function decrypt($payload, $unserialize = true)
      {
          $payload = $this->getJsonPayload($payload);
          $iv = base64_decode($payload['iv']);
          // Here we will decrypt the value. If we are able to successfully decrypt it
          // we will then unserialize it and return it out to the caller. If we are
          // unable to decrypt this value we will throw out an exception message.
          $decrypted = \openssl_decrypt(
              $payload['value'], $this->cipher, $this->key, 0, $iv
          );
          if ($decrypted === false) {
              throw new DecryptException('Could not decrypt the data.');
          }
          return $unserialize ? unserialize($decrypted) : $decrypted;
      }
      /**
       * Decrypt the given string without unserialization.
       *
       * @param  string  $payload
       * @return string
       */
      public function decryptString($payload)
      {
          return $this->decrypt($payload, false);
      }
      /**
       * Create a MAC for the given value.
       *
       * @param  string  $iv
       * @param  mixed  $value
       * @return string
       */
      protected function hash($iv, $value)
      {
          return hash_hmac('sha256', $iv.$value, $this->key);
      }
      /**
       * Get the JSON array from the given payload.
       *
       * @param  string  $payload
       * @return array
       *
       * @throws \Illuminate\Contracts\Encryption\DecryptException
       */
      protected function getJsonPayload($payload)
      {
          $payload = json_decode(base64_decode($payload), true);
          // If the payload is not valid JSON or does not have the proper keys set we will
          // assume it is invalid and bail out of the routine since we will not be able
          // to decrypt the given value. We'll also check the MAC for this encryption.
          if (! $this->validPayload($payload)) {
              throw new DecryptException('The payload is invalid.');
          }
          if (! $this->validMac($payload)) {
              throw new DecryptException('The MAC is invalid.');
          }
          return $payload;
      }
      /**
       * Verify that the encryption payload is valid.
       *
       * @param  mixed  $payload
       * @return bool
       */
      protected function validPayload($payload)
      {
          return is_array($payload) && isset(
              $payload['iv'], $payload['value'], $payload['mac']
          );
      }
      /**
       * Determine if the MAC for the given payload is valid.
       *
       * @param  array  $payload
       * @return bool
       */
      protected function validMac(array $payload)
      {
          $calculated = $this->calculateMac($payload, $bytes = random_bytes(16));
          return hash_equals(
              hash_hmac('sha256', $payload['mac'], $bytes, true), $calculated
          );
      }
      /**
       * Calculate the hash of the given payload.
       *
       * @param  array  $payload
       * @param  string  $bytes
       * @return string
       */
      protected function calculateMac($payload, $bytes)
      {
          return hash_hmac(
              'sha256', $this->hash($payload['iv'], $payload['value']), $bytes, true
          );
      }
      /**
       * Get the encryption key.
       *
       * @return string
       */
      public function getKey()
      {
          return $this->key;
      }
  }
  ```

  ​